---
title: "T1_BDML"
author: GARCIA BERNAL, ZAIRA ALEJANDRA RIVERA SANABRIA, LAURA SARIF JACOME VELASCO,
  NICOLAS VIAFARA MORALES, JORGE ELIECER
date: "2025-02-01"
output: html_document
---

# Problem set 1

## Introducción

LAU

## Data

" describir por qué decidismos utilizar las variables para estimar los modelos , AJUSTAR AL FINAL CON LOS MODELOS FINALES."

## Modelo de salario individual por hora

### Configuración inicial del ambiente

Para llevar a cabo el análisis, utilizamos "pacman" para facilitar la carga e instalación de varios paquetes en R que permiten la recolección, manipulación, exploración y visualización de datos. Así mismo, utilizaremos "p_load( )" para instalar y cargar multiples paquetes en unsa sola línea de codigo como se muestra a continuación:

```{r}
#if(!require(pacman)) install.packages("pacman") ; require(pacman)

p_load(rvest, # permite realizar web scraping en R
       dplyr, # Permite manipulación y transformación de los datos
       skimr,  # resumen estadístico
       visdat, # visualización de missing values
       corrplot, # correlation plots
       stargazer, # Tables/outputs to tex
       ggplot2 # graficación
       )
```

### Carga e inspección de los datos

#### 1. Proceso de carga de datos

LAU

```{r}
# Lista tablas
todas_las_tablas <- list()

# Iterar en las 10 paginas
for (i in 1:10) {
  url_tabla <- paste0("https://ignaciomsarmiento.github.io/GEIH2018_sample/pages/geih_page_", i, ".html")
  
  pagina_tabla <- read_html(url_tabla)
  
  # Extraer tabla
  tabla <- pagina_tabla %>% html_element("table") %>% html_table()
  
  # Agregar la tabla a la lista
  todas_las_tablas[[i]] <- tabla
}

# Unir todas las tablas en un solo dataframe
df_final <- bind_rows(todas_las_tablas)
```

#### 2. Proceso de inspección

LAU

```{r}
# Resumen de la Base de datos df_final
skim(df_final) %>% head()

df_final %>%
  select(age, ocu) %>%  # Visualizar solo las columnas clave
  sample_n(10)  # Mostrar 10 filas aleatorias

# Verificar estructura de las variables clave
str(df_final[, c("age", "ocu")])

# Filtrar personas mayores de 18 años que están empleadas
df_filtrado <- df_filtrado %>%
  filter(age >= 18, ocu == 1) 

head(df_filtrado)

# Limpieza de datos 
```

## Elección de varibles y valores faltantes

#### 1. Elección de variables

Se crea un nuevo data frame para con algunas de las variables que hacen parte de la GEIH, con el objetivo de explicar el salario por hora de una persona. A continuación se explican las variables elegidas y su pertinencia para la estimación del modelo.

***Escribir las variables***

```{r}
# Nuevo data frame
df_salario <- df_filtrado %>%
  select(y_total_m_ha, age, ocu, sex, maxEducLevel, p6426, p6870, depto, formal, p6100)

# cambio del nombre de algunas variables
df_salario <-  df_salario %>% 
  rename(salario_hora = y_total_m_ha,
         max_nivel_educ = maxEducLevel,
         tiempo_empresa = p6426,
         tamaño_empresa = p6870,
         segu_social = p6100
         )

# estadísticas de df_salario
skim(df_salario)
str(df_salario)
  
```

Así mismo, para poder trabjar con los datos de forma adecuda, es necesario realizar un análisis descirptivo de las variables seleccionadas como se muestra a continuación:

-   Tipos de datos:

    -   Numeric:

    -   Interger:

-   Estadísticas descriptivas por variables: (describir si tiene missing values, media, complete_rate, desviación estándar, cuartiles)

    -   y_total_ma_ha:

    -   age:

    -   ocu:

    -   sex:

    -   maxEducLevel:

    -   tiempo_empresa:

    -   tamaño_empresa:

    -   depto:

    -   formal:

    -   segu_social:

#### 2. Valores faltantes

Con el resumen de estadísticas del nuevo data frame creado, se identifica la cantidad de valores faltantes (n_missing) en las variabñes y_total_m_ha y en la variable p6100. A continuación, se procede a validar la información e imputar los valores necesarios para poder estimar los modelos.

```{r}
# datos faltantes con skim
base_faltantes <- skim(df_salario) %>% select( skim_variable, n_missing)

# calcular el porcentaje de valores faltantes
obs <- nrow(df_salario) 

base_faltantes<- base_faltantes %>% mutate(p_missing = n_missing/obs)
head(base_faltantes)

# ordenar de forma descendente
base_faltantes <- base_faltantes %>% arrange(-n_missing)

# mantener solo las variables con calores faltantes
base_faltantes<- base_faltantes %>% filter(n_missing!= 0)
base_faltantes

# gráfica de los valores faltantes
ggplot(base_faltantes, aes(x = reorder(skim_variable, -n_missing), y = p_missing, fill = skim_variable)) +
  geom_bar(stat = "identity", color = "black", width = 0.5) +  
  scale_y_continuous(labels = scales::percent) +  
  scale_fill_manual(values = c("lightsalmon", "lightpink", "lightblue")) +  
  labs(title = "Porcentaje de valores faltantes por variables", 
       x = "Variables",
       y = "Porcentaje de valores faltantes") + 
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1))

# Imputación de valores faltantes con la media

## Imputación a variables categóricas: max_nievl_educ y segu_social

### Calcular los calores mas comunes
educacion <- as.numeric(names(sort(table(df_salario$max_nivel_educ), decreasing = TRUE)[1]))

seg_soc <- as.numeric(names(sort(table(df_salario$segu_social), decreasing = TRUE)[1]))

### Imputación de los valores faltantes
df_salario <- df_salario  %>%
  mutate(max_nivel_educ = ifelse(is.na(max_nivel_educ) == TRUE, educacion , max_nivel_educ)) %>% 
  mutate(segu_social = ifelse(is.na(segu_social) == TRUE, seg_soc , segu_social))

# Distribución de la variable numérica: salario por hora
ggplot(df_salario, aes(salario_hora)) +
  geom_histogram(color = "#000000", fill = "#0099F8") +
  geom_vline(xintercept = median(df_salario$salario_hora, na.rm = TRUE), linetype = "dashed", color = "red") +
  geom_vline(xintercept = mean(df_salario$salario_hora, na.rm = TRUE), linetype = "dashed", color = "blue") +  
  ggtitle(" Ingreso Total por hora") +
  theme_classic() +
  theme(plot.title = element_text(size = 18))

## Debido a que la distribución del ingreso total por hora tiene un cola a la derecha, se deicide utilizar la mediana para imputar los valores faltantes.

df_salario <- df_salario %>% 
  mutate(salario_hora = ifelse(is.na(salario_hora) == TRUE, median(df_salario$salario_hora, na.rm = TRUE) , salario_hora))

# Validación de correcta imputación de valroes faltantes en el data frame de salario
sum(is.na(df_salario))
```
